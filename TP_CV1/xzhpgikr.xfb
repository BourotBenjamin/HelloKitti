#include <opencv2/core/core.hpp>
#include <opencv2/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/video.hpp>
#include <opencv2/calib3d.hpp>
#include <iostream>

using namespace cv;
using namespace std;



void findMatchings(Mat& image1, Mat& image2, std::vector<cv::Point2f>& points1, std::vector<cv::Point2f>& points2)
{
	std::vector<cv::Point2f> tmpA, tmpB;
	std::vector<unsigned char> status;
	cv::Mat errors;
	goodFeaturesToTrack(image1, tmpA, 500, 0.01, 10.0f);
	calcOpticalFlowPyrLK(image1, image2, tmpA, tmpB, status, errors);
	auto tmpABegin = tmpA.begin(), tmpBBegin = tmpB.begin();
	auto statusBegin = status.begin();
	while (tmpABegin != tmpA.end())
	{
		if ( (*statusBegin) == 1)
		{
			points1.push_back(*tmpABegin);
			points2.push_back(*tmpBBegin);
		}
		tmpABegin++;
		tmpBBegin++;
		statusBegin++;
	}
	std::cout << "Size :" << points1.size() << std::endl;
}


void showMatchings(Mat& image1, Mat& image2, std::vector<cv::Point2f>& points1, std::vector<cv::Point2f>& points2)
{
	//cv::line(ima)
	cv::imshow("l", image1);
	cv::imshow("r", image2);
	Size sz1 = image1.size();
	Size sz2 = image2.size();
	Mat im3(sz1.height, sz1.width + sz2.width, image1.type());
	Mat left(im3, Rect(0, 0, sz1.width, sz1.height));
	image1.copyTo(left);
	Mat right(im3, Rect(sz1.width, 0, sz2.width, sz2.height));
	image2.copyTo(right);
	Mat im3Color;
	cv::cvtColor(im3, im3Color, CV_GRAY2BGR);
	auto p1Ptr = points1.begin(), p2Ptr = points2.begin();
	while (p1Ptr != points1.end())
	{
		(*p2Ptr).x += sz2.width;
		cv::line(im3Color, *p1Ptr, *p2Ptr, cv::Scalar(255.0, 0.0, 0.0));
		(*p2Ptr).x -= sz2.width;
		p1Ptr++;
		p2Ptr++;
	}
	imshow("im3", im3Color);
}

void rectify(Mat& image1, Mat& image2, std::vector<cv::Point2f>& points1, std::vector<cv::Point2f>& points2, Mat& rectified1, Mat& rectified2)
{
	Mat fund = findFundamentalMat(points1, points2);
	Mat h1, h2;
	stereoRectifyUncalibrated(points1, points2, fund, image1.size(), h1, h2);
	warpPerspective(image1, rectified1, h1, image1.size());
	warpPerspective(image2, rectified2, h2, image2.size());
}

Mat& computeDisparity(Mat& rectified1, Mat& rectified2)
{
	Mat dispatiry;
	int ndisparities = 16 * 5;
	int SADWindowSize = 21;

	Ptr<StereoBM> sbm = StereoBM::create(ndisparities, SADWindowSize);
	sbm->compute(rectified1, rectified2, dispatiry);
}

int main(int argc, char* argv[])
{
	/*if (argc < 3)
	{
		std::cerr << "Required arguments: left.jpg right.jpg" << std::endl;
		return 1;
	}*/
	cv::Mat image1 = cv::imread("left.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	cv::Mat image2 = cv::imread("right.jpg", CV_LOAD_IMAGE_GRAYSCALE);
	std::vector<cv::Point2f> points1;
	std::vector<cv::Point2f> points2;
	findMatchings(image1, image2, points1, points2);
	findMatchings(image2, image1, points2, points1);
	showMatchings(image1, image2, points1, points2);
	cv::Mat rectified1(image1.size(), image1.type());
	cv::Mat rectified2(image2.size(), image2.type());
	rectify(image1, image2, points1, points2, rectified1, rectified2);
	cv::imshow("rectified L", rectified1);
	cv::imshow("rectified R", rectified2);
	/*cv::waitKey();
	cv::Mat disparity = computeDisparity(rectified1, rectified2);*/
	cv::waitKey();
	return 0;
}





/*

void TP1(Mat& image)
{
	std::vector<cv::Mat> channels(3);
	cv::split(image, channels);
	//imshow("R", channels[0]);
	//imshow("G", channels[1]);
	//imshow("B", channels[2]);
	Mat grey;
	cv::cvtColor(image, grey, CV_BGR2GRAY);
	//cvThreshold(&image, &out, 255, 100, 0);
	//imshow("Grey", grey);
	imshow("Display window", image);                   // Show our image inside it.

	Mat t = grey > 100;
	//imshow("T", t);
	std::vector<Mat> channels_t;
	char name = 'a';
	for (auto c = channels.begin(); c != channels.end(); ++c)
	{
		channels_t.push_back((*c > 100));
		name++;
		//imshow(""+name, (*c > 100));
	}
	Mat merge_t;
	merge(channels_t, merge_t);
	//imshow("Merge", merge_t);
	Mat hsv;
	cvtColor(image, hsv, CV_BGR2HSV);
	std::vector<Mat> hsv_channels(3);
	split(hsv, hsv_channels);
	//imshow("H0", hsv_channels[0]);
	//imshow("H1", hsv_channels[1]);
	//imshow("H2", hsv_channels[2]);
	hsv_channels[1] *= 2;
	Mat merge_h, merge_h2;
	merge(hsv_channels, merge_h);
	cvtColor(merge_h, merge_h, CV_HSV2BGR);
	imshow("Merge H", merge_h);
	//hsv_channels[1] /= 2;
	cv::Mat mask = (hsv_channels[0]>30) & (hsv_channels[0]<90);
	hsv_channels[1] = hsv_channels[1] & mask;
	merge(hsv_channels, merge_h2);
	cvtColor(merge_h2, merge_h2, CV_HSV2BGR);
	//imshow("Merge H2", merge_h2);
	cvtColor(hsv, hsv, CV_HSV2BGR);
	//imshow("HSV", hsv);
}

void TP2(Mat& image)
{

	Mat imgb, image_out;
	image.copyTo(image_out);
	Sobel(image, image_out, image.depth(), 1, 0);
	imshow("SOBEL1", image_out);
	Sobel(image, image_out, image.depth(), 0, 1);
	imshow("SOBEL2", image_out);
	Sobel(image, image_out, image.depth(), 1, 1);
	imshow("SOBEL3", image_out);
	Canny(image, image_out, 100.0, 50.0);
	imshow("Canny", image_out);
	blur(image, imgb, Size(3, 3));
	Canny(imgb, image_out, 100.0, 50.0);
	imshow("Canny B", image_out);
	Mat gray;
	cvtColor(image, gray, CV_BGR2GRAY);
}

int main(int argc, char** argv)
{

	Mat image;
	image = imread("img.jpg", CV_LOAD_IMAGE_COLOR);   // Read the file
	//TP1(image);
	TP2(image);
	waitKey(0);                                          // Wait for a keystroke in the window
	return 0;
}*/